I'll help you create a comprehensive plan for implementing the Integration Manager as your top priority feature. Let me first analyze your current integration setup and then provide a production-quality implementation plan.


[4 tools called]

Now let me check what other services exist and understand the current integration landscape:


[3 tools called]

Perfect! Now I have a comprehensive understanding of your current integration landscape. Let me create a production-quality implementation plan for the Integration Manager.

# Production-Quality Integration Manager Implementation Plan

## Current State Analysis

Your project currently has:
- ‚úÖ **Basic Integration Manager component** (placeholder)
- ‚úÖ **Supabase integration** (fully implemented)
- ‚úÖ **Google Blogger integration** (OAuth + API)
- ‚úÖ **Google Gemini AI integration** (content generation)
- ‚úÖ **Social Platform Service** (framework ready)
- ‚úÖ **Environment variable management** (Vite + process.env)

## Production-Quality Integration Manager Architecture

### Phase 1: Core Integration Infrastructure (Week 1)

#### 1.1 Enhanced Type Definitions
```typescript
// Add to types.ts
export interface Integration {
  id: string;
  userId: string;
  name: string;
  type: IntegrationType;
  platform: string;
  status: IntegrationStatus;
  credentials: EncryptedCredentials;
  configuration: IntegrationConfig;
  lastSync?: Date;
  syncFrequency: SyncFrequency;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface IntegrationConfig {
  webhooks?: WebhookConfig[];
  syncSettings?: SyncSettings;
  rateLimits?: RateLimitConfig;
  errorHandling?: ErrorHandlingConfig;
  notifications?: NotificationConfig;
}

export interface WebhookConfig {
  id: string;
  url: string;
  events: string[];
  secret: string;
  isActive: boolean;
  retryPolicy: RetryPolicy;
}

export interface SyncSettings {
  autoSync: boolean;
  syncInterval: number; // minutes
  batchSize: number;
  retryAttempts: number;
  timeoutMs: number;
}

export interface IntegrationStatus {
  connected: boolean;
  lastSync?: Date;
  syncInProgress: boolean;
  errorCount: number;
  lastError?: string;
  healthScore: number; // 0-100
}
```

#### 1.2 Integration Service Layer
```typescript
// services/integrationService.ts
export class IntegrationService {
  private integrations: Map<string, Integration> = new Map();
  private syncJobs: Map<string, NodeJS.Timeout> = new Map();
  
  // Core CRUD operations
  async createIntegration(data: CreateIntegrationData): Promise<Integration>
  async updateIntegration(id: string, updates: Partial<Integration>): Promise<Integration>
  async deleteIntegration(id: string): Promise<void>
  async getIntegrations(): Promise<Integration[]>
  async getIntegration(id: string): Promise<Integration | null>
  
  // Connection management
  async connectIntegration(id: string): Promise<boolean>
  async disconnectIntegration(id: string): Promise<void>
  async testConnection(id: string): Promise<ConnectionTestResult>
  
  // Sync management
  async startSync(id: string): Promise<void>
  async stopSync(id: string): Promise<void>
  async syncAll(): Promise<SyncResult[]>
  
  // Health monitoring
  async checkIntegrationHealth(id: string): Promise<HealthCheckResult>
  async getIntegrationMetrics(id: string): Promise<IntegrationMetrics>
}
```

#### 1.3 Database Schema Extensions
```sql
-- Add to enhanced-schema-migration.sql
CREATE TABLE IF NOT EXISTS integrations (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  type TEXT NOT NULL CHECK (type IN ('social_media', 'analytics', 'crm', 'email', 'storage', 'ai_service')),
  platform TEXT NOT NULL,
  status JSONB DEFAULT '{"connected": false, "syncInProgress": false, "errorCount": 0, "healthScore": 0}',
  credentials JSONB NOT NULL, -- Encrypted
  configuration JSONB DEFAULT '{}',
  last_sync TIMESTAMPTZ,
  sync_frequency INTEGER DEFAULT 60, -- minutes
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS integration_webhooks (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  integration_id UUID REFERENCES integrations(id) ON DELETE CASCADE,
  url TEXT NOT NULL,
  events TEXT[] DEFAULT '{}',
  secret TEXT NOT NULL,
  is_active BOOLEAN DEFAULT true,
  retry_policy JSONB DEFAULT '{"maxRetries": 3, "backoffMultiplier": 2}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS integration_logs (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  integration_id UUID REFERENCES integrations(id) ON DELETE CASCADE,
  level TEXT CHECK (level IN ('info', 'warn', 'error', 'debug')),
  message TEXT NOT NULL,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS integrations_user_id_idx ON integrations(user_id);
CREATE INDEX IF NOT EXISTS integrations_platform_idx ON integrations(platform);
CREATE INDEX IF NOT EXISTS integrations_status_idx ON integrations USING GIN (status);
CREATE INDEX IF NOT EXISTS integration_logs_integration_id_idx ON integration_logs(integration_id);
CREATE INDEX IF NOT EXISTS integration_logs_created_at_idx ON integration_logs(created_at DESC);

-- RLS policies
ALTER TABLE integrations ENABLE ROW LEVEL SECURITY;
ALTER TABLE integration_webhooks ENABLE ROW LEVEL SECURITY;
ALTER TABLE integration_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can access own integrations" ON integrations
  FOR ALL USING (auth.uid() = user_id);

CREATE POLICY "Users can access own webhooks" ON integration_webhooks
  FOR ALL USING (
    EXISTS (SELECT 1 FROM integrations WHERE id = integration_webhooks.integration_id AND user_id = auth.uid())
  );

CREATE POLICY "Users can access own integration logs" ON integration_logs
  FOR ALL USING (
    EXISTS (SELECT 1 FROM integrations WHERE id = integration_logs.integration_id AND user_id = auth.uid())
  );
```

### Phase 2: Platform-Specific Integrations (Week 2)

#### 2.1 Social Media Platform Integrations
```typescript
// services/integrations/socialMediaIntegrations.ts
export class SocialMediaIntegrations {
  // Twitter/X Integration
  async connectTwitter(credentials: TwitterCredentials): Promise<Integration>
  async syncTwitterData(integrationId: string): Promise<SyncResult>
  async postToTwitter(integrationId: string, content: TwitterPost): Promise<PostResult>
  
  // LinkedIn Integration
  async connectLinkedIn(credentials: LinkedInCredentials): Promise<Integration>
  async syncLinkedInData(integrationId: string): Promise<SyncResult>
  async postToLinkedIn(integrationId: string, content: LinkedInPost): Promise<PostResult>
  
  // Facebook Integration
  async connectFacebook(credentials: FacebookCredentials): Promise<Integration>
  async syncFacebookData(integrationId: string): Promise<SyncResult>
  async postToFacebook(integrationId: string, content: FacebookPost): Promise<PostResult>
  
  // Instagram Integration
  async connectInstagram(credentials: InstagramCredentials): Promise<Integration>
  async syncInstagramData(integrationId: string): Promise<SyncResult>
  async postToInstagram(integrationId: string, content: InstagramPost): Promise<PostResult>
  
  // TikTok Integration
  async connectTikTok(credentials: TikTokCredentials): Promise<Integration>
  async syncTikTokData(integrationId: string): Promise<SyncResult>
  async postToTikTok(integrationId: string, content: TikTokPost): Promise<PostResult>
}
```

#### 2.2 Analytics Platform Integrations
```typescript
// services/integrations/analyticsIntegrations.ts
export class AnalyticsIntegrations {
  // Google Analytics
  async connectGoogleAnalytics(credentials: GoogleAnalyticsCredentials): Promise<Integration>
  async syncGoogleAnalyticsData(integrationId: string): Promise<SyncResult>
  
  // Facebook Analytics
  async connectFacebookAnalytics(credentials: FacebookAnalyticsCredentials): Promise<Integration>
  async syncFacebookAnalyticsData(integrationId: string): Promise<SyncResult>
  
  // Twitter Analytics
  async connectTwitterAnalytics(credentials: TwitterAnalyticsCredentials): Promise<Integration>
  async syncTwitterAnalyticsData(integrationId: string): Promise<SyncResult>
}
```

#### 2.3 AI Service Integrations
```typescript
// services/integrations/aiServiceIntegrations.ts
export class AIServiceIntegrations {
  // OpenAI Integration
  async connectOpenAI(credentials: OpenAICredentials): Promise<Integration>
  async generateContentWithOpenAI(integrationId: string, prompt: string): Promise<string>
  
  // Claude Integration
  async connectClaude(credentials: ClaudeCredentials): Promise<Integration>
  async generateContentWithClaude(integrationId: string, prompt: string): Promise<string>
  
  // Custom AI Models
  async connectCustomAI(credentials: CustomAICredentials): Promise<Integration>
  async generateContentWithCustomAI(integrationId: string, prompt: string): Promise<string>
}
```

### Phase 3: Advanced Integration Manager UI (Week 3)

#### 3.1 Main Integration Manager Component
```typescript
// components/IntegrationManager.tsx
const IntegrationManager: React.FC<IntegrationManagerProps> = ({
  isOpen,
  onClose,
  onIntegrationUpdate
}) => {
  const [activeTab, setActiveTab] = useState<'overview' | 'add' | 'configure' | 'monitor'>('overview');
  const [integrations, setIntegrations] = useState<Integration[]>([]);
  const [selectedIntegration, setSelectedIntegration] = useState<Integration | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');

  // Integration management functions
  const loadIntegrations = async () => { /* ... */ };
  const createIntegration = async (data: CreateIntegrationData) => { /* ... */ };
  const updateIntegration = async (id: string, updates: Partial<Integration>) => { /* ... */ };
  const deleteIntegration = async (id: string) => { /* ... */ };
  const testConnection = async (id: string) => { /* ... */ };
  const syncIntegration = async (id: string) => { /* ... */ };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg shadow-xl w-full max-w-7xl max-h-[90vh] overflow-hidden">
        {/* Header with tabs */}
        <div className="flex items-center justify-between p-6 border-b">
          <h2 className="text-2xl font-bold text-gray-900">Integration Manager</h2>
          <button onClick={onClose} className="text-gray-400 hover:text-gray-600 text-2xl">√ó</button>
        </div>

        {/* Tab Navigation */}
        <div className="flex border-b">
          {[
            { key: 'overview', label: 'Overview', icon: 'üìä' },
            { key: 'add', label: 'Add Integration', icon: '‚ûï' },
            { key: 'configure', label: 'Configure', icon: '‚öôÔ∏è' },
            { key: 'monitor', label: 'Monitor', icon: 'üìà' }
          ].map(tab => (
            <button
              key={tab.key}
              onClick={() => setActiveTab(tab.key as any)}
              className={`px-6 py-3 font-medium text-sm border-b-2 transition-colors ${
                activeTab === tab.key
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700'
              }`}
            >
              <span className="mr-2">{tab.icon}</span>
              {tab.label}
            </button>
          ))}
        </div>

        {/* Tab Content */}
        <div className="p-6 overflow-y-auto max-h-[calc(90vh-200px)]">
          {activeTab === 'overview' && <IntegrationOverview />}
          {activeTab === 'add' && <AddIntegration />}
          {activeTab === 'configure' && <ConfigureIntegration />}
          {activeTab === 'monitor' && <MonitorIntegrations />}
        </div>
      </div>
    </div>
  );
};
```

#### 3.2 Integration Overview Component
```typescript
// components/integrations/IntegrationOverview.tsx
const IntegrationOverview: React.FC = () => {
  return (
    <div className="space-y-6">
      {/* Integration Status Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {integrations.map(integration => (
          <IntegrationCard
            key={integration.id}
            integration={integration}
            onTestConnection={testConnection}
            onSync={syncIntegration}
            onConfigure={() => setSelectedIntegration(integration)}
            onDelete={deleteIntegration}
          />
        ))}
      </div>

      {/* Quick Actions */}
      <div className="bg-gray-50 p-4 rounded-lg">
        <h3 className="text-lg font-semibold mb-4">Quick Actions</h3>
        <div className="flex flex-wrap gap-3">
          <button
            onClick={() => syncAllIntegrations()}
            className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
          >
            Sync All Integrations
          </button>
          <button
            onClick={() => checkAllHealth()}
            className="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700"
          >
            Health Check All
          </button>
          <button
            onClick={() => exportIntegrationData()}
            className="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700"
          >
            Export Data
          </button>
        </div>
      </div>

      {/* Integration Metrics */}
      <IntegrationMetrics integrations={integrations} />
    </div>
  );
};
```

#### 3.3 Add Integration Component
```typescript
// components/integrations/AddIntegration.tsx
const AddIntegration: React.FC = () => {
  const [selectedPlatform, setSelectedPlatform] = useState<string>('');
  const [integrationType, setIntegrationType] = useState<IntegrationType>('social_media');
  const [credentials, setCredentials] = useState<Record<string, string>>({});
  const [isConnecting, setIsConnecting] = useState(false);

  const availableIntegrations = {
    social_media: [
      { id: 'twitter', name: 'Twitter/X', icon: 'üê¶', description: 'Post tweets and sync engagement data' },
      { id: 'linkedin', name: 'LinkedIn', icon: 'üíº', description: 'Share professional content and network' },
      { id: 'facebook', name: 'Facebook', icon: 'üìò', description: 'Post to pages and groups' },
      { id: 'instagram', name: 'Instagram', icon: 'üì∑', description: 'Share photos and stories' },
      { id: 'tiktok', name: 'TikTok', icon: 'üéµ', description: 'Create and share short videos' }
    ],
    analytics: [
      { id: 'google_analytics', name: 'Google Analytics', icon: 'üìä', description: 'Track website and content performance' },
      { id: 'facebook_analytics', name: 'Facebook Analytics', icon: 'üìà', description: 'Monitor social media performance' }
    ],
    ai_service: [
      { id: 'openai', name: 'OpenAI', icon: 'ü§ñ', description: 'Advanced AI content generation' },
      { id: 'claude', name: 'Claude', icon: 'üß†', description: 'Anthropic AI assistant' }
    ]
  };

  return (
    <div className="space-y-6">
      {/* Integration Type Selection */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-3">
          Integration Type
        </label>
        <div className="grid grid-cols-3 gap-4">
          {Object.entries(availableIntegrations).map(([type, platforms]) => (
            <button
              key={type}
              onClick={() => setIntegrationType(type as IntegrationType)}
              className={`p-4 border-2 rounded-lg text-left transition-colors ${
                integrationType === type
                  ? 'border-blue-500 bg-blue-50'
                  : 'border-gray-200 hover:border-gray-300'
              }`}
            >
              <div className="font-medium capitalize">{type.replace('_', ' ')}</div>
              <div className="text-sm text-gray-500">{platforms.length} integrations</div>
            </button>
          ))}
        </div>
      </div>

      {/* Platform Selection */}
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-3">
          Select Platform
        </label>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {availableIntegrations[integrationType].map(platform => (
            <div
              key={platform.id}
              onClick={() => setSelectedPlatform(platform.id)}
              className={`p-4 border-2 rounded-lg cursor-pointer transition-colors ${
                selectedPlatform === platform.id
                  ? 'border-blue-500 bg-blue-50'
                  : 'border-gray-200 hover:border-gray-300'
              }`}
            >
              <div className="flex items-center mb-2">
                <span className="text-2xl mr-3">{platform.icon}</span>
                <div>
                  <div className="font-medium">{platform.name}</div>
                  <div className="text-sm text-gray-500">{platform.description}</div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Credentials Form */}
      {selectedPlatform && (
        <IntegrationCredentialsForm
          platform={selectedPlatform}
          type={integrationType}
          credentials={credentials}
          onCredentialsChange={setCredentials}
          onConnect={handleConnect}
          isConnecting={isConnecting}
        />
      )}
    </div>
  );
};
```

### Phase 4: Advanced Features (Week 4)

#### 4.1 Webhook Management
```typescript
// components/integrations/WebhookManager.tsx
const WebhookManager: React.FC<{ integrationId: string }> = ({ integrationId }) => {
  const [webhooks, setWebhooks] = useState<WebhookConfig[]>([]);
  const [showAddWebhook, setShowAddWebhook] = useState(false);

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">Webhooks</h3>
        <button
          onClick={() => setShowAddWebhook(true)}
          className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700"
        >
          Add Webhook
        </button>
      </div>

      <div className="space-y-3">
        {webhooks.map(webhook => (
          <WebhookCard
            key={webhook.id}
            webhook={webhook}
            onEdit={handleEditWebhook}
            onDelete={handleDeleteWebhook}
            onTest={handleTestWebhook}
          />
        ))}
      </div>

      {showAddWebhook && (
        <AddWebhookModal
          integrationId={integrationId}
          onClose={() => setShowAddWebhook(false)}
          onAdd={handleAddWebhook}
        />
      )}
    </div>
  );
};
```

#### 4.2 Real-time Monitoring Dashboard
```typescript
// components/integrations/IntegrationMonitor.tsx
const IntegrationMonitor: React.FC = () => {
  const [metrics, setMetrics] = useState<IntegrationMetrics[]>([]);
  const [alerts, setAlerts] = useState<IntegrationAlert[]>([]);
  const [logs, setLogs] = useState<IntegrationLog[]>([]);

  // Real-time updates via WebSocket
  useEffect(() => {
    const ws = new WebSocket(process.env.VITE_WS_URL || 'ws://localhost:3001');
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      if (data.type === 'integration_metrics') {
        setMetrics(data.metrics);
      } else if (data.type === 'integration_alert') {
        setAlerts(prev => [data.alert, ...prev.slice(0, 99)]);
      } else if (data.type === 'integration_log') {
        setLogs(prev => [data.log, ...prev.slice(0, 999)]);
      }
    };

    return () => ws.close();
  }, []);

  return (
    <div className="space-y-6">
      {/* Metrics Overview */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        <MetricCard
          title="Total Integrations"
          value={metrics.length}
          trend="+2"
          color="blue"
        />
        <MetricCard
          title="Active Connections"
          value={metrics.filter(m => m.status.connected).length}
          trend="+1"
          color="green"
        />
        <MetricCard
          title="Sync Errors"
          value={metrics.reduce((sum, m) => sum + m.status.errorCount, 0)}
          trend="-3"
          color="red"
        />
        <MetricCard
          title="Avg Health Score"
          value={Math.round(metrics.reduce((sum, m) => sum + m.status.healthScore, 0) / metrics.length)}
          trend="+5"
          color="purple"
        />
      </div>

      {/* Alerts */}
      <div className="bg-white rounded-lg shadow p-6">
        <h3 className="text-lg font-semibold mb-4">Recent Alerts</h3>
        <div className="space-y-2">
          {alerts.map(alert => (
            <AlertItem key={alert.id} alert={alert} />
          ))}
        </div>
      </div>

      {/* Logs */}
      <div className="bg-white rounded-lg shadow p-6">
        <h3 className="text-lg font-semibold mb-4">Integration Logs</h3>
        <div className="space-y-1 max-h-96 overflow-y-auto">
          {logs.map(log => (
            <LogItem key={log.id} log={log} />
          ))}
        </div>
      </div>
    </div>
  );
};
```

#### 4.3 Integration Testing & Validation
```typescript
// services/integrationTesting.ts
export class IntegrationTesting {
  async testConnection(integration: Integration): Promise<ConnectionTestResult> {
    const startTime = Date.now();
    
    try {
      switch (integration.platform) {
        case 'twitter':
          return await this.testTwitterConnection(integration);
        case 'linkedin':
          return await this.testLinkedInConnection(integration);
        case 'google_analytics':
          return await this.testGoogleAnalyticsConnection(integration);
        default:
          return { success: false, error: 'Unsupported platform' };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        responseTime: Date.now() - startTime
      };
    }
  }

  async validateCredentials(platform: string, credentials: any): Promise<ValidationResult> {
    // Validate credential format and test basic connectivity
    const validation = await this.performValidation(platform, credentials);
    
    if (!validation.success) {
      return {
        valid: false,
        errors: validation.errors,
        suggestions: this.getCredentialSuggestions(platform, validation.errors)
      };
    }

    return { valid: true, errors: [], suggestions: [] };
  }

  async runHealthCheck(integrationId: string): Promise<HealthCheckResult> {
    const integration = await integrationService.getIntegration(integrationId);
    if (!integration) {
      throw new Error('Integration not found');
    }

    const checks = await Promise.allSettled([
      this.testConnection(integration),
      this.testDataSync(integration),
      this.testWebhooks(integration),
      this.testRateLimits(integration)
    ]);

    const results = checks.map((check, index) => ({
      check: ['connection', 'sync', 'webhooks', 'rate_limits'][index],
      success: check.status === 'fulfilled' && check.value.success,
      error: check.status === 'rejected' ? check.reason : check.value.error
    }));

    const healthScore = (results.filter(r => r.success).length / results.length) * 100;

    return {
      integrationId,
      healthScore,
      checks: results,
      timestamp: new Date(),
      recommendations: this.generateHealthRecommendations(results)
    };
  }
}
```

### Phase 5: Security & Performance (Week 5)

#### 5.1 Credential Encryption
```typescript
// services/credentialEncryption.ts
export class CredentialEncryption {
  private static readonly ALGORITHM = 'AES-256-GCM';
  private static readonly KEY_LENGTH = 32;
  private static readonly IV_LENGTH = 16;

  static async encrypt(credentials: any, userKey: string): Promise<EncryptedCredentials> {
    const key = await this.deriveKey(userKey);
    const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));
    
    const cipher = crypto.createCipher(this.ALGORITHM, key);
    cipher.setAAD(Buffer.from(userKey));
    
    const encrypted = Buffer.concat([
      cipher.update(JSON.stringify(credentials), 'utf8'),
      cipher.final()
    ]);
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted: encrypted.toString('base64'),
      iv: Buffer.from(iv).toString('base64'),
      authTag: authTag.toString('base64'),
      algorithm: this.ALGORITHM
    };
  }

  static async decrypt(encryptedCredentials: EncryptedCredentials, userKey: string): Promise<any> {
    const key = await this.deriveKey(userKey);
    const iv = Buffer.from(encryptedCredentials.iv, 'base64');
    const authTag = Buffer.from(encryptedCredentials.authTag, 'base64');
    const encrypted = Buffer.from(encryptedCredentials.encrypted, 'base64');
    
    const decipher = crypto.createDecipher(encryptedCredentials.algorithm, key);
    decipher.setAAD(Buffer.from(userKey));
    decipher.setAuthTag(authTag);
    
    const decrypted = Buffer.concat([
      decipher.update(encrypted),
      decipher.final()
    ]);
    
    return JSON.parse(decrypted.toString('utf8'));
  }

  private static async deriveKey(userKey: string): Promise<Buffer> {
    // Use PBKDF2 to derive encryption key from user key
    return new Promise((resolve, reject) => {
      crypto.pbkdf2(userKey, 'integration-salt', 100000, this.KEY_LENGTH, 'sha256', (err, key) => {
        if (err) reject(err);
        else resolve(key);
      });
    });
  }
}
```

#### 5.2 Rate Limiting & Error Handling
```typescript
// services/rateLimiting.ts
export class RateLimiting {
  private static rateLimits = new Map<string, RateLimitTracker>();

  static async checkRateLimit(integrationId: string, operation: string): Promise<RateLimitResult> {
    const key = `${integrationId}:${operation}`;
    const tracker = this.rateLimits.get(key) || new RateLimitTracker();
    
    const now = Date.now();
    const windowStart = now - (60 * 1000); // 1 minute window
    
    // Clean old requests
    tracker.requests = tracker.requests.filter(timestamp => timestamp > windowStart);
    
    const limit = this.getRateLimit(operation);
    const remaining = Math.max(0, limit - tracker.requests.length);
    
    if (tracker.requests.length >= limit) {
      return {
        allowed: false,
        remaining: 0,
        resetTime: tracker.requests[0] + (60 * 1000),
        retryAfter: Math.ceil((tracker.requests[0] + (60 * 1000) - now) / 1000)
      };
    }
    
    tracker.requests.push(now);
    this.rateLimits.set(key, tracker);
    
    return {
      allowed: true,
      remaining: remaining - 1,
      resetTime: now + (60 * 1000),
      retryAfter: 0
    };
  }

  private static getRateLimit(operation: string): number {
    const limits = {
      'api_call': 100, // 100 API calls per minute
      'data_sync': 10,  // 10 sync operations per minute
      'webhook': 1000,  // 1000 webhook calls per minute
      'test_connection': 5 // 5 connection tests per minute
    };
    
    return limits[operation as keyof typeof limits] || 50;
  }
}
```

## Implementation Timeline

### Week 1: Foundation
- [ ] Create enhanced type definitions
- [ ] Implement IntegrationService class
- [ ] Add database schema extensions
- [ ] Set up credential encryption

### Week 2: Platform Integrations
- [ ] Implement social media integrations (Twitter, LinkedIn, Facebook, Instagram)
- [ ] Add analytics platform integrations (Google Analytics, Facebook Analytics)
- [ ] Create AI service integrations (OpenAI, Claude)
- [ ] Implement connection testing and validation

### Week 3: UI Components
- [ ] Build main IntegrationManager component
- [ ] Create IntegrationOverview component
- [ ] Implement AddIntegration component
- [ ] Add ConfigureIntegration component

### Week 4: Advanced Features
- [ ] Implement webhook management
- [ ] Create real-time monitoring dashboard
- [ ] Add integration testing framework
- [ ] Build alert and notification system

### Week 5: Security & Performance
- [ ] Implement credential encryption
- [ ] Add rate limiting and error handling
- [ ] Create performance monitoring
- [ ] Add comprehensive logging

## Key Features Summary

### üîê Security Features
- **Credential Encryption**: AES-256-GCM encryption for all API keys and tokens
- **Rate Limiting**: Platform-specific rate limiting to prevent API abuse
- **Access Control**: Row-level security with user-based access control
- **Audit Logging**: Comprehensive logging of all integration activities

### üìä Monitoring & Analytics
- **Real-time Health Monitoring**: Live status updates and health scores
- **Performance Metrics**: Response times, success rates, and error tracking
- **Alert System**: Proactive notifications for integration issues
- **Usage Analytics**: Track integration usage and performance trends

### üîÑ Automation Features
- **Auto-sync**: Configurable automatic data synchronization
- **Webhook Management**: Real-time event notifications
- **Error Recovery**: Automatic retry logic with exponential backoff
- **Batch Processing**: Efficient bulk operations for large datasets

### üé® User Experience
- **Intuitive UI**: Clean, modern interface with drag-and-drop functionality
- **One-click Setup**: Streamlined integration setup process
- **Visual Status Indicators**: Clear visual feedback for integration health
- **Mobile Responsive**: Works seamlessly on all device sizes

This production-quality Integration Manager will provide a robust, secure, and user-friendly way to manage all your external platform integrations.